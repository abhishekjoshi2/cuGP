<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>cuGP by sgoyal78 and abhishekjoshi2</title>


  <script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>

 <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">

    <style>
    table, td, th {    
	border: 1px solid #ddd;
	text-align: left;
    }

    table {
	border-collapse: collapse;
	}

	th, td {
	padding: 15px;
	}

  </style>
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">cuGP</h1>
      <h2 class="project-tagline">GPU Accelerated Gaussian Process for Regression</h2>
      <a href="https://github.com/abhishekjoshi2/cuGP" class="btn">View on GitHub</a>
      <a href="https://github.com/abhishekjoshi2/cuGP/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/abhishekjoshi2/cuGP/tarball/master" class="btn">Download .tar.gz</a>
      <a href="https://abhishekjoshi2.github.io/cuGP/checkpoint.html" class="btn">Checkpoint</a>
      <a href="https://abhishekjoshi2.github.io/cuGP/proposal.html" class="btn">Proposal</a>
    </section>

    <section class="main-content">



      <h3>
<a id="Checkpoint Update" class="anchor" href="#checkpoint" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Checkpoint Update</h3>


<ul>

<li> <b>Implementing Gaussian Process Regression in C++:</b></li>
<p> As planned, we have successfully implemented Gaussian Process Regression in C++. This proved to be harder than what we had expected, since many of the implementation intricacies cropped up as we started coding each step. We have tested our code against an implementation of Gaussian Process Regression in Matlab (GPML toolbox by Rasmussen and Nickisch), and we have achieved full accuracy in all stages of the computation.</p>

<li> <b>Implementing 2 Covariance Kernels:</b></li>
<p> We have implemented 2 covariance kernels: Squared Exponential Kernel along with the Noise Kernel. For now, we have pushed the task of implementing the third covariance kernel to a lower priority task, since we don't think it is crucial to our task of "parallelizing Gaussian Process", and would be more suited to a primarily ML-focused project. Moreover, implementing SE Kernel + Noise Kernel is sufficient for implementing the whole training and regression task.
</p>

<li> <b>Naively parallelizing Gaussian Process in CUDA:</b></li>
<p> As planned, we have also successfully ported a naive version of Gaussian Process regression code in CUDA. This involved breaking down many of the steps of the computation into modular and reusable parts of code that are amenable to be run on CUDA. We will now briefly describe the different kernels that we have implemented as a part of the whole stack. For all kernels, X is the input training matrix, N is the number of training samples, and DIM is the number of parameters for each training sample:</p>

<ul>
<li> <b> compute_K_train: </b></li>

<p> We launch N*N threads - one for each element in the N*N covariance matrix. Each thread picks up its required input working set from the X matrix and fills up the (i,j)th entry in the K matrix, which is the covariance matrix. This can be further improved by collaborative loading of X into shared memory.</p>

<li> <b> compute_cholesky: </b></li>
<p> We use Cholesky factorization to factorize the K matrix into a lower triangular matrix L (and its corresponding upper triangular matrix U). Cholesky factorization is further broken down into a series of kernels such as taking offsetted transpose, rectangular forward substitution, generic matrix transpose, matrix multiplication, and offsetted matrix subtraction. We implemented parallel Cholesky by referring to the algorithm given in [DA14]. Currently, for taking the pure Cholesky in the first step of the recursive process, we have fixed our <i>b</i> parameter to be 2. Going forward, we hope to try doing the same for <i>b = 3</i> and <i>b = 4</i>.</p>

<li> <b> matrix_transpose: </b></li>
<p> Matrix transpose is needed at several points during training, and therefore we have written a naive implementation of matrix transpose in CUDA, where the (i, j)th thread fills up the (j, i)th entry in the transpose matrix. We are not sure if there are better ways to do this, and we will be on the look out for a better implementation. </p>

<li> <b> matrix_multiplication: </b></li>
<p> Matrix multiplication is another important piece of our implementation, and currently we have a naively parallel version of matrix multiplication where we launch one thread for every element of the output matrix. Going forward, we plan to implemented the same using shared memory and collaboratively loading data sets into shared memory.</p>

<li> <b> rectangular_forward_substitution: </b></li>
<p> Forward substitution helps us solve equations of the form <i><b>AX = B</b></i> where A, X, B are matrices, A and B are known, and X is unknown. For now, we launch one thread for each column of X, since each column is independent of each other.</p>

<li> <b> determinant_lower_triangular_matrix: </b></li>
<p> We need the determinant of the lower triangular matrix U. We thought we might have to implement a parallel version for finding the determinant, but later realized that the determinant can be naively taken by taking the square of the product of the diagonal elements! We launch one thread for taking the determinant, which sequentially walks the whole diagonal and calculates the product of all the elements.</p>

<li> <b> vector_forward_substution and vector_backward_substitution: </b></li>
<p> This is the most sequential part of the whole system, and is currently a major bottleneck. For now, we have an extremely naively parallel version in CUDA, which doesn't perform well. We had expected this, and will now implement a different algorithm for implementing these two kernels, which is more amenable to parallelizing on CUDA.</p>

<li> <b> compute_squared_distance, elementwise_matrix_mult, subtract_matrices, get_outer_product: </b></li>
<p> All these kernels have been naively parallelized by launching one thread for each element, since each of them can be done without any dependencies. </p>

</ul>

<li> <b> Schedule and Progress </b></li>
Please find our progress below (at the end of the page). We would say that we are in sync with our proposed schedule :D.
</ul>

<h3><a id="updatedschedule" class="anchor" href="#updatedschedule" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Updated Schedule</h3>

<ul>

<li>22nd April</li>

<ul>
<li>Improve performance of all kernels except vector forward and backward substitution. Use blocking and shared memory as much as possible.</li>
<li>Start work on performance evaluation to find places where the framework takes a long time. Find bottlenecks. </li>
</ul>

<li>26th April</li>
<ul>
<li>Improve performance of vector forward and backward substitution</li>
</ul>

<li>30th April</li>
<ul> 
<li>Start work on distributed version of cuGP if possible. Otherwise, continue work on forward and backward substitution optimization. (This is exam week, so we don't want to go overboard on our tasks). </li>
</ul>

<li>4th May</li>
<ul>
<li>Finish all work</li>
<li>Evaluate system performance and fine tune different parameters</li>
</ul>

<li>7th May</li>
<ul>
<li>Code drop in</li>
<li>Finish writeup</li>
</ul>
</ul>

<h3><a id="finaldemo" class="anchor" href="#finaldemo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Final Demo</h3>
For the final demo, we will show graphs of our system's performance and show speedups as against the serial version.

  <h3>
<a id="Prelim-results" class="anchor" href="#presults" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Preliminary Results</h3>

<p>
The figure below shows the time it takes to obtain the Cholesky decomposition for 2 different dataset sizes (N = 500 and N = 1000 samples) for the serial GP implementation vs the naive GPU implemnentation. We see that the speedup for N = 1000 is around 10x.
<img src="images/compare_chol.png" alt="comparison of Cholesky">

The figure below shows the time taken for computing the log marginal likelihood for the 2 implementations. The worse performance of our naive GPU implementation is as expected. This is because our forward subsitution and backward substition modules are run by a single CUDA thread (due to the inherent sequential nature of the algorithm itself). This time includes the time taken by the Cholesky and the forward-backward substitution routines.
<img src="images/compare_ll.png" alt="comparison of log likelihood">
</p>



  <h3>
<a id="Current-Challenges" class="anchor" href="#challenges" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Current Challenges</h3>

We have identified 2 key challenges that have to be addressed for an efficient final CUDA implementation:
<ul>
<li> <b> Cholesky decomposition </b> </li>
<p> In the computation of the log marginal-likelihood we need to perform Cholesky decomposition of the covariance matrix. As of now we have implemented a blocked-recursive algorithm for computing it. However, we think that a better use of shared memory and a hybrid algorithm would surely be beneficial. </p>

<li> <b> Triangular Matrix Inversion </b> </li> 
<p> Triangular matrix inversion (TMI) basically comprises of the forward-substitution routines for both vectors as well as matrices. Due to the inherently sequential algorithm for solving forward/backward substitution for a vector, currently, our CUDA kernel implemention for it is quite naive. We have gone through some recent papers, and have found a recursive algorithm that seems to be more CUDA friendly. So one of our primary goals is to implement an efficient triangular matrix inversion module.   </p>
  
</ul>

<h3>
<a id="nicetohaves" class="anchor" href="#nicetohaves" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Nice-to-have</h3>
We are contemplating moving to a distributed enviroment once we optimize our single node performance. We would then be able to extract extremely high performance from multiple GPUs. However, this is definitely a stretch goal for us, and would be undertaken only after we feel confident about our single node performance.

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/abhishekjoshi2/cuGP">cuGP</a> is maintained by <a href="https://github.com/sidgoyal78">sidgoyal78</a> and <a href="https://github.com/abhishekjoshi2">abhishekjoshi2</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

